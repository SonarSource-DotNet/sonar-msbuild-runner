/*
 * SonarScanner for .NET
 * Copyright (C) 2016-2024 SonarSource SA
 * mailto: info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using SonarScanner.MSBuild.Common;

namespace SonarScanner.MSBuild.PreProcessor;

public static class AnalysisConfigGenerator
{
    private const string SonarExclusions = "sonar.exclusions";

    /// <summary>
    /// Combines the various configuration options into the AnalysisConfig file
    /// used by the build and post-processor. Saves the file and returns the config instance.
    /// </summary>
    /// <param name="localSettings">Processed local settings, including command line arguments supplied the user.</param>
    /// <param name="buildSettings">Build environment settings.</param>
    /// <param name="additionalSettings">Additional settings generated by this Scanner. Can be empty.</param>
    /// <param name="serverProperties">Analysis properties downloaded from the SonarQube server.</param>
    /// <param name="analyzersSettings">Specifies the Roslyn analyzers to use. Can be empty.</param>
    /// <param name="sonarQubeVersion">SonarQube/SonarCloud server version.</param>
    /// <param name="resolvedJavaExePath">Java exe path calculated from IJreResolver.</param>
    public static AnalysisConfig GenerateFile(ProcessedArgs localSettings,
        BuildSettings buildSettings,
        Dictionary<string, string> additionalSettings,
        IDictionary<string, string> serverProperties,
        List<AnalyzerSettings> analyzersSettings,
        string sonarQubeVersion,
        string resolvedJavaExePath)
    {
        _ = localSettings ?? throw new ArgumentNullException(nameof(localSettings));
        _ = buildSettings ?? throw new ArgumentNullException(nameof(buildSettings));
        _ = additionalSettings ?? throw new ArgumentNullException(nameof(additionalSettings));
        _ = serverProperties ?? throw new ArgumentNullException(nameof(serverProperties));
        _ = analyzersSettings ?? throw new ArgumentNullException(nameof(analyzersSettings));
        var config = new AnalysisConfig
        {
            SonarConfigDir = buildSettings.SonarConfigDirectory,
            SonarOutputDir = buildSettings.SonarOutputDirectory,
            SonarBinDir = buildSettings.SonarBinDirectory,
            SonarScannerWorkingDirectory = buildSettings.SonarScannerWorkingDirectory,
            SourcesDirectory = buildSettings.SourcesDirectory,
            JavaExePath = string.IsNullOrWhiteSpace(localSettings.JavaExePath) ? resolvedJavaExePath : localSettings.JavaExePath, // the user-specified JRE overrides the resolved value
            ScanAllAnalysis = localSettings.ScanAllAnalysis,
            HasBeginStepCommandLineCredentials = localSettings.CmdLineProperties.HasProperty(SonarProperties.SonarUserName)
                                                 || localSettings.CmdLineProperties.HasProperty(SonarProperties.SonarToken),
            SonarQubeHostUrl = localSettings.ServerInfo.ServerUrl,
            SonarQubeVersion = sonarQubeVersion,
            SonarProjectKey = localSettings.ProjectKey,
            SonarProjectVersion = localSettings.ProjectVersion,
            SonarProjectName = localSettings.ProjectName,
            ServerSettings = new(),
            LocalSettings = new(),
            AnalyzersSettings = analyzersSettings
        };
        config.SetBuildUri(buildSettings.BuildUri);
        config.SetTfsUri(buildSettings.TfsUri);
        config.SetVsCoverageConverterToolPath(buildSettings.CoverageToolUserSuppliedPath);
        foreach (var item in additionalSettings)
        {
            config.SetConfigValue(item.Key, item.Value);
        }
        foreach (var property in serverProperties.Where(x => !Utilities.IsSecuredServerProperty(x.Key)))
        {
            AddSetting(config.ServerSettings, property.Key, property.Value);
        }
        foreach (var property in localSettings.CmdLineProperties.GetAllProperties()) // Only those from command line
        {
            AddSetting(config.LocalSettings, property.Id, property.Value);
        }
        if (!string.IsNullOrEmpty(localSettings.Organization))
        {
            AddSetting(config.LocalSettings, SonarProperties.Organization, localSettings.Organization);
        }
        if (localSettings.PropertiesFileName is not null)
        {
            config.SetSettingsFilePath(localSettings.PropertiesFileName);
        }

        CoverageExclusions.UpdateConfig(config, localSettings, serverProperties);
        config.Save(buildSettings.AnalysisConfigFilePath);
        return config;
    }

    private static void AddSetting(AnalysisProperties properties, string id, string value)
    {
        var property = new Property(id, value);

        // Ensure it isn't possible to write sensitive data to the config file
        if (!property.ContainsSensitiveData())
        {
            properties.Add(new(id, value));
        }
    }

    // See https://sonarsource.atlassian.net/browse/SCAN4NET-29
    // This class is a hack and should be removed when we properly support excluding coverage files in the scanner-engine (https://sonarsource.atlassian.net/browse/SCANENGINE-18).
    // The idea is that we are manually adding the coverage paths to the exclusions, so that they do not appear on the analysis.
    private static class CoverageExclusions
    {
        private const string VsCoverageReportsPaths = "sonar.cs.vscoveragexml.reportsPaths";
        private const string OpenCoverReportsPaths = "sonar.cs.opencover.reportsPaths";
        private const string DotCoverReportsPaths = "sonar.cs.dotcover.reportsPaths";

        public static void UpdateConfig(AnalysisConfig config, ProcessedArgs localSettings, IDictionary<string, string> serverProperties)
        {
            var coveragePaths = CoveragePaths(localSettings, serverProperties);
            if (localSettings.ScanAllAnalysis  // If scanAll analysis is disabled, we will not pick up the coverage files anyways
                && coveragePaths.Length > 0)   // If there are no coverage files, there is nothing to exclude
            {
                UpdateConfig(config, localSettings, serverProperties, string.Join(",", coveragePaths));
            }
        }

        private static void UpdateConfig(AnalysisConfig config, ProcessedArgs localSettings, IDictionary<string, string> serverProperties, string coveragePaths)
        {
            var localExclusions = localSettings.GetSetting(SonarExclusions, string.Empty);
            var serverExclusions = serverProperties.ContainsKey(SonarExclusions) ? serverProperties[SonarExclusions] : string.Empty;

            if (string.IsNullOrEmpty(localExclusions) && string.IsNullOrEmpty(serverExclusions))
            {
                localExclusions = coveragePaths;
            }
            else if (string.IsNullOrEmpty(localExclusions))
            {
                localExclusions = string.Join(",", serverExclusions, coveragePaths);
            }
            else
            {
                localExclusions += "," + coveragePaths;
            }
            // Recreate LocalSettings property
            if (config.LocalSettings.Exists(x => x.Id == SonarExclusions)
                || !string.IsNullOrWhiteSpace(localExclusions))
            {
                config.LocalSettings.RemoveAll(x => x.Id == SonarExclusions);
                AddSetting(config.LocalSettings, SonarExclusions, localExclusions);
            }
        }

        private static string[] CoveragePaths(ProcessedArgs localSettings, IDictionary<string, string> serverProperties)
        {
            var localProperties = localSettings.AllProperties().ToList();
            var coveragePaths = new List<string>
            {
                CoveragePaths(localProperties, serverProperties, VsCoverageReportsPaths),
                CoveragePaths(localProperties, serverProperties, OpenCoverReportsPaths),
                CoveragePathsAndDirectories(localProperties, serverProperties, DotCoverReportsPaths),
            };

            return coveragePaths.Where(x => x is not null).ToArray();
        }

        private static string CoveragePaths(List<Property> localProperties, IDictionary<string, string> serverProperties, string propertyName)
        {
            if (localProperties.Find(x => x.Id == propertyName) is { } localProperty)
            {
                return localProperty.Value;
            }
            else if (serverProperties.TryGetValue(propertyName, out var serverProperty))
            {
                return serverProperty;
            }
            return null;
        }

        private static string CoveragePathsAndDirectories(List<Property> localProperties, IDictionary<string, string> serverProperties, string propertyName)
        {
            if (CoveragePaths(localProperties, serverProperties, propertyName) is { } coveragePaths)
            {
                var paths = new List<string>();
                foreach (var path in coveragePaths.Split(',').Where(x => !string.IsNullOrWhiteSpace(x)))
                {
                    paths.Add(path);

                    var lastDot = path.LastIndexOf('.');
                    if (lastDot == -1)          // coverage -> coverage/**
                    {
                        paths.Add($"{path}/**");
                    }
                    else if (lastDot > 0)       // coverage.one.html -> coverage.one/**
                    {
                        paths.Add($"{path.Substring(0, lastDot)}/**");
                    }
                }

                return string.Join(",", paths);
            }

            return null;
        }
    }
}
